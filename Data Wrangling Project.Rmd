---
title: "Capstone Data Wrangling"
author: "Simone Zanetti"
date: "10/5/2018"
output: html_document
---

```{r}
library(tidyr)
library(dplyr)
library(chron)
library(ggplot2)
library(ggmap)
```

```{r}
data_clean <- 
```
              
# ERASE THE FIRST ROW THAT IS NOT RELEVANT TO MY DATASET
```{r}
data_clean <- data_clean[-1,]
```

----------------------------------------

# 1. CHANGE NAME OF EACH VARIABLE TO MAKE THEM UNDERSTABLE
```{r}
data_clean <- data_clean %>% rename( "dep_to_bs" = `DATA PART`,
                                     "arr_to_bs" = `DATA ARR`,
                                     "delivery_day" = `DATA CONS`,
                                     "sender_who" = MITT,
                                     "addresser_who" = DITTA,
                                     "address_delivery"= IND,
                                     "district_delivery" = LOC,
                                     "weight_pack" = PESO,        
                                     "num_pack"= COLLI,
                                     "driver_code" = CODICE,
                                     "pickup_who"= FIRMA,
                                     "pickup_time" = ORA)
```

## Uniform each name to Lower character

```{r}
data_clean <- data_clean %>% 
              mutate_all(funs(tolower(.)))
```


----------------------------------------

# 2. DEALING WITH MISSING VALUES

I provide an *overwiew of which variables contain missing values* and *how many* creating a temporary variable useful for the analysis.
```{r}
missing_values <- data_clean %>% summarise_all(funs(sum(is.na(.)))) %>% gather(variable, num_NA) 
```

Once I identified which variables contain missing values I decide how to manage them:

**1. addressee_who**
```{r}
data_clean %>% filter(is.na(addresser_who))      #in order to check which rows contain NA in the variable and decide how to manage it
data_clean <- data_clean %>%  mutate(addresser_who = replace(addresser_who,is.na(addresser_who), "UNKNOWN"))
```

**2. address_delivery**
```{r}
data_clean %>% filter(is.na(address_delivery))   #in order to check which rows contain NA in the variable and decide how to manage it
data_clean <- data_clean %>%  
              mutate(address_delivery = replace(address_delivery,addresser_who == "giancarlo pagnoni", "villaggio badia,trav. seconda")) # I could see that "giancarlo pagnoni" has lot of deliveries: in this way I have modified the NA using the address of the deliveries with no NA.
data_clean <- data_clean %>%  mutate(address_delivery = replace(address_delivery,is.na(address_delivery), "UNKNOWN"))
```


**3. driver_code**
```{r}
data_clean %>% filter(is.na(driver_code))    #in order to check which rows contain NA in the variable and decide how to manage it
```
I do not need the rows with "fermo deposito" as address delivery, as it means these deliveries have been picked up directly on the factory
```{r}
data_clean <- data_clean %>% filter(data_clean$address_delivery != "fermo deposito")
```

**4. pickup_time**

I cannot recover the missing hours, but I can lead an analysis of the missing hours to eventually find out trends.
So, I create a dataframe with the missing hours
```{r}
NA_pickuptime_foranalysis <- data_clean %>%  mutate(pickup_time = replace(pickup_time,is.na(pickup_time), 0 )) %>% 
                 filter(pickup_time == 0)
```

After, I delete the rows containing the Missing hours.
```{r}
data_clean<- data_clean %>% filter(data_clean$pickup_time > 0)
```

----------------------------------------

# 3. FIXING DIFFERENCES OF SPELLING (on variables in which this is necessary)

**A.DISTRICT_DELIVERY**  
I create a variable to analyse 
```{r}
district_distinct <- group_by(data_clean, district_delivery) %>% summarise()  
```

```{r}
data_clean <- data_clean %>% 
  mutate(district_delivery = sub(pattern = "roe.*" , "roe' volciano", district_delivery))
```

**B.ADDRESS_DELIVERY**  
I create a variable to analyse 
```{r}
address_distinct <- group_by(data_clean, address_delivery) %>% summarise()  
```
In this case I have over 80k rows.
*First thing* I should do is to erase the number on the street that make the research too unusefully precise.
```{r}
data_clean <- data_clean %>%
              mutate(address_delivery= gsub("[[:digit:]]","",address_delivery))  
              # QUESTION N.3: MAYBE AVOID ALL THE PUNCTUATION WITH [:punct:] would work ?
```

----------------------------------------

# 4. TURN ADDRESS INTO COORDINATES 

In this particular case I have Two possibilities of approach:

1) I **associate each district with its CAP** (the italian zip code) in order to perform my analysis within each CAP.  

In order to do so, I add to each row of "district_distinct" the name "Brescia" that will be useful for the Google geocoding system to recover the necessary data regarding each district.

```{r}
district_distinct <- district_distinct %>%  mutate(city = "Brescia") %>% unite(district_distinct, district_delivery, city, sep = "-" ) # IS THERE A SHORTER WAY ?

district_distinct$district_distinct <- as.character(district_distinct$district_distinct)

googlegeo <- geocode(location = district_distinct$district_distinct, output = c("more"))

googlegeo <- googlegeo %>% select( locality, administrative_area_level_3,postal_code)

googlegeo <- bind_cols(googlegeo, district_distinct)

googlegeoNA <- filter(googlegeo, is.na(googlegeo$postal_code))

googlegeoNA <- googlegeoNA %>%  select(district_distinct)

googlegeoNA$district_distinct <- as.character(googlegeoNA$district_distinct)

# -------- Repeat the operation to fill the NA

googlegeo2 <- geocode(location = googlegeoNA$district_distinct, output = c("more"))

googlegeo2 <- googlegeo2 %>% select( locality, administrative_area_level_3,postal_code)

googlegeo2 <- bind_cols(googlegeo2, googlegeoNA)

googlegeo2NA <- filter(googlegeo2, is.na(googlegeo2$postal_code)) 

googlegeo2NA <- googlegeo2NA %>%  select(district_distinct)

googlegeo2NA$district_distinct <- as.character(googlegeo2NA$district_distinct)

# -------- Repeat the operation to fill the NA

googlegeo3 <- geocode(location = googlegeo2NA$district_distinct, output = c("more")) 

googlegeo3 <- googlegeo3 %>% select( locality, administrative_area_level_3,postal_code)

googlegeo3 <- bind_cols(googlegeo3, googlegeo2NA)

googlegeo3NA <- filter(googlegeo3, is.na(googlegeo3$postal_code)) 

googlegeo3NA <- googlegeo3NA %>%  select(district_distinct)

googlegeo3NA$district_distinct <- as.character(googlegeo3NA$district_distinct)

# -------- Repeat the operation to fill the NA

googlegeo4 <- geocode(location = googlegeo3NA$district_distinct, output = c("more")) 

googlegeo4 <- googlegeo4 %>% select( locality, administrative_area_level_3,postal_code)

googlegeo4 <- bind_cols(googlegeo4, googlegeo3NA)

# OPERATION NECESSARY TO OBTAIN A COMPLETE DATAFRAME

googlegeo1_clean <- googlegeo %>% filter(!is.na(googlegeo$postal_code))

googlegeo2_clean <- googlegeo2 %>% filter(!is.na(googlegeo2$postal_code))

googlegeo3_clean <- googlegeo3 %>% filter(!is.na(googlegeo3$postal_code))

finalcapgeocoding <- bind_rows(googlegeo1_clean,googlegeo2_clean,googlegeo3_clean,googlegeo4)

finalcapgeocoding <- finalcapgeocoding %>% mutate(district_distinct = gsub(pattern = "-Brescia$", replacement = "",district_distinct))

finalcapgeocoding <- finalcapgeocoding %>% rename( "district_delivery" = district_distinct )

data_clean <- left_join(data_clean,finalcapgeocoding, by = "district_delivery")


```

I have to **analyse the NA of these new variables**

### Postal_codeNA

```{r}
postal_codeNA <- unique(postal_codeNA$district_delivery)
View(postal_codeNA)
```

I manually fill in the missing values

```{r}

data_clean <- data_clean %>% 
  mutate(postal_code = replace(postal_code, district_delivery == "ghedi", "25016") , 
           postal_code = replace(postal_code, district_delivery == "san faustino", "25070") , 
           postal_code = replace(postal_code, district_delivery == "agnosine", "25071"),
           postal_code = replace(postal_code, district_delivery == "tavernole sul mella", "25060"),
         postal_code = replace(postal_code, district_delivery== "pezzo", "25056"),
         postal_code = replace(postal_code, district_delivery== "corzano", "25030"),
         postal_code = replace(postal_code, district_delivery== "san felice del benaco", "25010"),
         postal_code = replace(postal_code, district_delivery== "fornaci", "25131"),
         postal_code = replace(postal_code, district_delivery== "gardone riviera", "25083"),
         postal_code = replace(postal_code, district_delivery== "pregno", "25069"),
         postal_code = replace(postal_code, district_delivery== "gazzane", "25070"),
         postal_code = replace(postal_code, district_delivery== "toscolano m.", "25088"),
         postal_code = replace(postal_code, district_delivery== "lugana", "25019"),
         postal_code = replace(postal_code, district_delivery== "mandolossa", "25030"),
         postal_code = replace(postal_code, district_delivery== "brescia", "25121/25136"),
         postal_code = replace(postal_code, district_delivery== "lido di lonato", "25017"),
         postal_code = replace(postal_code, district_delivery== "badia", "25132"),
         postal_code = replace(postal_code, district_delivery== "corona", "25079"),
         postal_code = replace(postal_code, district_delivery== "tovo", "25088"),
         postal_code = replace(postal_code, is.na(postal_code), "UNKNOWN"),
         postal_code = replace(postal_code, postal_code == "30016", "UNKNOWN"),
         postal_code = replace(postal_code, postal_code == "V9410", "UNKNOWN"))

```

### "Administrative_area_level_3"

I manage "administrative_area_level_3" and the the missing values in there

```{r}
data_clean <- data_clean %>% select(-locality) %>%  rename("locality_delivery" = district_delivery, "district_delivery" = administrative_area_level_3)


# CODE NOT NEEDED SO FAR ---------------------------------------------
capunique <- data_clean %>% select(district_delivery, postal_code)   
capunique <- unique(capunique)
attempt <- left_join(data_clean, capunique, by = "postal_code")
# ----------------------------------------------------------------------

data_clean <- data_clean %>% 
              mutate_all(funs(tolower(.)))

```


2) I **turn the addresses into coordinates** with the google geocoding as well, creating a variable address_lat and variable address_long.

In this case it is necessary to reduce the variable address_distinct to its minimum, ensuring to have optimally fixed the differences of spelling,  since the google geocoding system allows to make 2.5k queries per day.
```{r}
# NOT STRICTLY NECESSARY SO FAR
```



# 5. WORKING WITH DATES 

_ Duplicate the variable "delivery_day" in order to keep it after I will have it split as following:

```{r}
data_clean <- data_clean %>% mutate(delivery_date = delivery_day)
```

_ Convert character string to Dates regarding the variables "dep_to_bs", "arr_to_bs", "delivery_day"
```{r}
data_clean <- data_clean %>% mutate(dep_to_bs = as.Date( x = dep_to_bs, format = "%d / %m / %y"),
                                    arr_to_bs = as.Date(x = arr_to_bs, format = "%d / %m / %y"),
                                    delivery_date = as.Date(x = delivery_date, format = "%d / %m / %y"))
```


_ Obtain the variable "weekday_deliv"
```{r}
data_clean <- data_clean %>% mutate(weekday_deliv = format(delivery_date, "%a"))  
```



_ Split delivery_day column into 3 variables
```{r}
data_clean <- data_clean %>% separate(delivery_day, c("day_deliv", "month_deliv", "year_deliv"), sep = "/")
```



_ Trasform dates in a better format  (ISSUE: IT TURNS THEM INTO CHARACTER AGAIN)
```{r}
data_clean <- data_clean %>% mutate(dep_to_bs = format( x = dep_to_bs, format = "%d/%m/%y"),
                                    arr_to_bs = format(x = arr_to_bs, format = "%d/%m/%y"))
```




_ In case I will just work with March data, I will not need variable "month_deliv" and "year_deliv"
```{r}
data_clean <- select(data_clean, - month_deliv, - year_deliv)
```



# 6. WORKING WITH HOURS
_ Convert character string to time regarding the variable "pickup_time"
(The following section code needs to be improved)
```{r}
data_clean <- data_clean %>% mutate(pickup_time =  as.POSIXct(x = data_clean$pickup_time, format = "%H:%M")) %>% 
              mutate(pickup_time = gsub(pattern = "2018-05-16", replacement = "",x = pickup_time))    
data_clean <- data_clean %>% mutate(pickup_time = times(x = pickup_time))

```

_ Create a variable to perform operation with hours, converting each hour in minutes (past midnight?)
```{r}
# HOW TO DO IT ?
```


# 7.CONVERT NECESSARY VARIABLES INTO NUMERICS

```{r}

data_clean$weight_pack <- 
data_clean$num_pack <- as.numeric(data_clean$num_pack)
```


# SUMMARY: CREATE NEW DATAFRAMES USEFUL FOR MY ANALYSIS

```{r}

dataexploratory <-  data_clean %>% select(-dep_to_bs, - arr_to_bs, month_deliv, - year_deliv, - sender_who, - pickup_who)

# TO BE COMPLETED DURING THE EXPLORATORY ANALYSIS
```

